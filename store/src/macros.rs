//! Macros managing requests and responses.
//!
//! Our protocol uses the Result(T) type to communicate rich errors to
//! the client.  These macros deal with sending a request using the
//! asynchronous I/O framework Tokio, and decoding the result.
//!
//! This implementation uses macros instead of functions to interface
//! with the code stubs generated by the RPC compiler.

// Sends request and decodes result.
//
// Sends the given request and decodes the result.
macro_rules! invoke {
    ($requ: expr) => {
        $requ.send().promise.await?.get()?.get_result()?.which()?.into_result()
    }
}

// Sends request and decodes result.
//
// Sends the given request and decodes the result.
macro_rules! make_request {
    ( $core: expr, $request: expr ) => {{
        use futures_util::TryFutureExt;
        use crate::node::result::Which;

        let r: std::result::Result<Result<_>, capnp::Error> = $core.block_on(
            $request.send().promise
                .and_then(|response| -> Promise<Result<_>, capnp::Error> {
                    let r = pry!(pry!(pry!(response.get()).get_result()).which());
                    let r = match r {
                        /* The Result.  */
                        Which::Ok(Ok(x)) => Ok(x),
                        Which::Err(Ok(e)) => Err(anyhow::Error::from(e)),
                        /* Protocol violations.  */
                        Which::Ok(Err(e)) => Err(anyhow::Error::from(e)),
                        Which::Err(Err(e)) => Err(anyhow::Error::from(e)),
                    };
                    Promise::ok(r)
                }));
        r?
    }}
}

macro_rules! make_request_map {
    ( $core: expr, $request: expr, $map: expr ) => {{
        use futures_util::TryFutureExt;
        use crate::node::result::Which;

        let r: std::result::Result<Result<_>, capnp::Error> = $core.block_on(
            $request.send().promise
                .and_then(|response| -> Promise<Result<_>, capnp::Error> {
                    let r = pry!(pry!(pry!(response.get()).get_result()).which());
                    let r = match r {
                        /* The Result.  */
                        Which::Ok(Ok(x)) => $map(x),
                        Which::Err(Ok(e)) => Err(anyhow::Error::from(e)),
                        /* Protocol violations.  */
                        Which::Ok(Err(e)) => Err(anyhow::Error::from(e)),
                        Which::Err(Err(e)) => Err(anyhow::Error::from(e)),
                    };
                    Promise::ok(r)
                }));
        r?
    }}
}

/// These macros are for server functions.  Because they use the
/// 'results' parameter, they must be bound explicitly at the
/// beginning of the function.
macro_rules! bind_results {
    ( $results: ident ) => {
        #[allow(unused)]
        const DEBUG_BACKEND_ERRORS: bool = false;

        /// Behaves like `return Err(_)` for server functions.
        #[allow(unused_macros)]
        macro_rules! fail {
            ( $expr:expr ) => {{
                if DEBUG_BACKEND_ERRORS {
                    eprintln!("{}:{}: {:?}", file!(), line!(), $expr);
                }
                pry!($results.get().get_result()).set_err($expr);
                return Promise::ok(());
            }};
        }

        /// Behaves like `try!` for server functions.
        ///
        /// If the given expression evaluates to Err(_), the error is
        /// stored in the result and the function terminates.
        #[allow(unused_macros)]
        macro_rules! sry {
            ( $expr:expr ) => {{
                match $expr {
                    Ok(x) => x,
                    Err(x) => {
                        if DEBUG_BACKEND_ERRORS {
                            eprintln!("{}:{}: {:?}", file!(), line!(), x);
                        }
                        pry!($results.get().get_result()).set_err(x.into());
                        return Promise::ok(());
                    },
                }
            }};
        }
    };
}

// Tracing infrastructure.
macro_rules! trace {
    ( $TRACE:expr, $fmt:expr, $($pargs:expr),* ) => {
        if $TRACE {
            eprintln!($fmt, $($pargs),*);
        }
    };
    ( $TRACE:expr, $fmt:expr ) => {
        trace!($TRACE, $fmt, );
    };
}

// Converts an indentation level to whitespace.
pub(crate) fn indent(i: isize) -> &'static str {
    use std::convert::TryFrom;
    let s = "                                                  ";
    &s[0..std::cmp::min(usize::try_from(i).unwrap_or(0), s.len())]
}

macro_rules! tracer {
    ( $TRACE:expr, $func:expr ) => {
        tracer!($TRACE, $func, 0)
    };
    ( $TRACE:expr, $func:expr, $indent:expr ) => {
        // Currently, Rust doesn't support $( ... ) in a nested
        // macro's definition.  See:
        // https://users.rust-lang.org/t/nested-macros-issue/8348/2
        macro_rules! t {
            ( $fmt:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, $fmt) };
            ( $fmt:expr, $a:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a)) };
            ( $fmt:expr, $a:expr, $b:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a, $b)) };
            ( $fmt:expr, $a:expr, $b:expr, $c:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a, $b, $c)) };
            ( $fmt:expr, $a:expr, $b:expr, $c:expr, $d:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a, $b, $c, $d)) };
            ( $fmt:expr, $a:expr, $b:expr, $c:expr, $d:expr, $e:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a, $b, $c, $d, $e)) };
            ( $fmt:expr, $a:expr, $b:expr, $c:expr, $d:expr, $e:expr, $f:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a, $b, $c, $d, $e, $f)) };
            ( $fmt:expr, $a:expr, $b:expr, $c:expr, $d:expr, $e:expr, $f:expr, $g:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a, $b, $c, $d, $e, $f, $g)) };
            ( $fmt:expr, $a:expr, $b:expr, $c:expr, $d:expr, $e:expr, $f:expr, $g:expr, $h:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a, $b, $c, $d, $e, $f, $g, $h)) };
            ( $fmt:expr, $a:expr, $b:expr, $c:expr, $d:expr, $e:expr, $f:expr, $g:expr, $h:expr, $i:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a, $b, $c, $d, $e, $f, $g, $h, $i)) };
            ( $fmt:expr, $a:expr, $b:expr, $c:expr, $d:expr, $e:expr, $f:expr, $g:expr, $h:expr, $i:expr, $j:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a, $b, $c, $d, $e, $f, $g, $h, $i, $j)) };
            ( $fmt:expr, $a:expr, $b:expr, $c:expr, $d:expr, $e:expr, $f:expr, $g:expr, $h:expr, $i:expr, $j:expr, $k:expr ) =>
            { trace!($TRACE, "{}{}: {}", crate::macros::indent($indent), $func, format!($fmt, $a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k)) };
        }
    }
}
